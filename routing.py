import argparse

def ReadData(db_path, with_direction = 0, with_weight = 0):
    print("Loading data from path {} ...".format(db_path))
    raw_graph = [] # saves the original graph link list
    node_weight = {} # saves weight for each nodes
    node_link = {} # saves {node: {next_node:distance}}
    with open(db_path, "r") as f:
        a = f.readline() # read dataset line by line
        while(a):
            if ('#' not in a) and (',' in a): # ignore the commented line by # symbol in dataset
                temp_list = a.rstrip('\n').split(",") # split line into elements by comma
                fn = temp_list[0] # fn means from_node, the first element in dataset line
                en = temp_list[1] # en means end_node, the second element in dataset line
                temp_list[2] = float(temp_list[2]) # saves the distance into float format, it is the 3th element in dataset line
                if with_weight: # if have weight, continue to read the 4th and 5th element in dataset line
                    try:
                        fn_w = float(temp_list[3]) # fn_w means from node's weight, the 4th element in dataset
                        en_w = float(temp_list[4]) # en_w means end node's weight, the 5th element in dataset
                    except:
                        raise TypeError("Dataset {} have no weight information provided in standard format!".format(db_path)) # if dataset have no weight, raise an error
                else:
                    fn_w = float(1) # if no weight given, just set nodes weight as 1 (all the 1 so no weight)
                    en_w = float(1)
                node_weight[fn] = fn_w # set the node_weight list with from node
                node_weight[en] = en_w # set the node_weight list with end node
                raw_graph.append(temp_list[:3]) # raw_graph only receives from_node, end_node, distance so is 0,1,2 colume
            a = f.readline() # continue read another line in dataset
    nodes = set(t[0] for t in raw_graph) | set(t[1] for t in raw_graph) # shuffle all the nodes and get rid of the duplicated nodes
    nodes = sorted(nodes) # sort nodes name, just for better present in a a-b-c or 1-2-3 sequence, no other meaning
    for i in nodes: # initialize the node_link which saves each 'node->next_node->distance'
        node_link[i] = dict()
    for i in raw_graph:
        # this iteration initializes the node_link with distance value between nodes
        nodea, nodeb, distance = i
        node_link[nodea][nodeb] = distance
        if with_direction == 0: # if dataset do not have direction, set node_link in the reverse sequence (like a double linked pointer in C++)
            node_link[nodeb][nodea] = distance
    node_str = ""
    for n in nodes:
        # just for print each node name in sequence
        str_t = "{} ".format(n)
        node_str += str_t
    print("totally {} nodes detected from dataset, they have {} and {}:\n{}".format(len(nodes), "direction" if with_direction else "no direction", "nodes weight" if with_weight else "no weight", node_str))
    print("The edges between nodes and nodes' weight:")
    print("Node_a\tNode_b\tDist\tWeighta\tWeightb")
    printed = set()
    # Below code print each node, their next node, the distance, the weight of a node, weight of b node.
    for i in nodes:
        for j in node_link[i]:
            if j not in printed and not with_direction:
                print("{}\t{}\t{}\t{}\t{}".format(i,j,node_link[i][j],node_weight[i],node_weight[j]))
            elif with_direction:
                print("{}\t{}\t{}\t{}\t{}".format(i,j,node_link[i][j],node_weight[i],node_weight[j]))
        printed.add(i)
    return node_link, raw_graph, node_weight
    
    

def BellmanFord(dest_node, node_lk):
    # Have-direction BellmanFord Algorithm
    # Parameters:
    #     dest_node: str, the destination node name
    #     node_lk: dict, generated by DataRead() in Format like
    #         node_lk:{'a':{'b':2,'c':3},'b':{'e':1}}
    #         saves from node (fn), end node (en) and distance between fn and en
    # Return:
    #     None, print out the min distance from every node to the destination node
    
    nodes = sorted(node_lk.keys())
    dist_mat = dict() # dist_mat saves every nodes' distance to destination node
    for i in nodes:
        dist_mat[i] = [-1, float("inf")] # initialize everything with [-1, inf]
    dist_mat[dest_node][0] = 'self' # the destination node it self should be ['self', 0]
    dist_mat[dest_node][1] = 0
    for i in range(len(nodes)-1):
        # do iteratations to find the shortest path from each node to destination node.
        for fn in nodes:
        # for all the nodes
        # Update dist value and parent index of the adjacent vertices of the picked vertex. Consider only those vertices which are still in queue.
            for en in list(node_lk[fn].keys()):
                if dist_mat[en][1] != float('inf') and dist_mat[en][1] + node_lk[fn][en] < dist_mat[fn][1]: # if the updated value is smaller, change the node's next hop and its distance
                    dist_mat[fn][1] = dist_mat[en][1] + node_lk[fn][en]
                    dist_mat[fn][0] = en
        #print("{}th iteration:\n{}".format(i, dist_mat))
    print("----------------------------------------------")
    print("Testing if there exists negtive weighted loop")
    for fn in nodes:
        # for every nodes, detect if theres an negtive loop
        for en in node_lk[fn]:
            if dist_mat[fn][1] != float("inf") and dist_mat[fn][1] + node_lk[fn][en] < dist_mat[en][1]:
                # If negtive loop exists, there would be one path have shorter distance from the saved dist_mat.
                print("Negtive weighted loop tested!")
                return None
    print(">>> No Negtive weighted loop!")
    print("----------------------------------------------")
    print('Distance to vertice {}'.format(dest_node))
    print('Node\tNext\tDistance')
    # just print out every nodes and its next hop and the distance to destination node.
    for i in nodes:
        if i != dest_node:
            print("{}\t{}\t{}".format(i, dist_mat[i][0], dist_mat[i][1]))



def Dijkstra(start_node, node_lk):
    # Have-direction Dijkstra Algorithm
    # Parameters:
    #     start_node: str, the start node name
    #     node_lk: dict, generated by DataRead() in Format like
    #         node_lk:{'a':{'b':2,'c':3},'b':{'e':1}}
    #         saves from node (fn), end node (en) and distance between fn and en
    # Return:
    #     None, print out the min distance from start_node to every other nodes in graph
    
    nodes = sorted(node_lk.keys())
    path_nodes = set()
    path_nodes.add(start_node)
    unknown_nodes = set(nodes) - path_nodes
    dist_mat = dict() # dist_mat saves every nodes' distance to destination node
    for i in nodes:
        dist_mat[i] = [-1, float("inf")] # '-1' as undefined previous node, 'inf' as distance be infinite 
    dist_mat[start_node][0] = 'self' # the start node it self should be ['self', 0]
    dist_mat[start_node][1] = 0
    while unknown_nodes: # If there still have unknown nodes
        for fn in path_nodes: # for every node in the best path
            for en in node_lk[fn].keys(): # search all their children nodes
                if dist_mat[fn][1] + node_lk[fn][en] < dist_mat[en][1]:
                    dist_mat[en][1] = dist_mat[fn][1] + node_lk[fn][en] # Update from-src-distance for updated end_node 
                    dist_mat[en][0] = fn # Update previous-node for updated end_node
        # below finds the node with minimum distance from start node, and add it to best path (path_nodes)
        temp_min_value = float('inf')
        for i in sorted(unknown_nodes):
            if dist_mat[i][1] < temp_min_value:
                current_min_node = i # any comparation find smaller distance, update the node name i
                temp_min_value = dist_mat[i][1] # and update the minimum distance
        unknown_nodes.remove(current_min_node) # find out the minimum distance node, remove it from the nodes that not in best path
        path_nodes.add(current_min_node) # and add it to best path.
    print("----------------------------------------------")
    print('Distance from vertice {}'.format(start_node))
    print('Node\tFrom\tDistance')
    # below just print nodes, previous hop and the distance from source node
    for i in nodes:
        if i != start_node:
            print("{}\t{}\t{}".format(i, dist_mat[i][0], dist_mat[i][1]))
            


def AstarSearch(start_node, goal_node, node_lk, node_weight):
    # Directed weighted shortest path algorithm from node a to b
    # Parameters:
    #     start_node: str, the start node name
    #     end_node: str, the destination node name
    #     node_lk: dict, generated by DataRead() in Format like
    #         node_lk:{'a':{'b':2,'c':3},'b':{'e':1}}
    #         saves from node (fn), end node (en) and distance between fn and en
    #     node_weight: dict, generated by DataRead() in Format like
    #         node_lk:{'a':2, 'b':3}
    #         saves every nodes' weight
    # Return:
    #     None, print out the min path from start_node to certain destination node in graph
    
    nodes = sorted(node_lk.keys())
    path_nodes = set() 
    path_nodes.add(start_node)
    unknown_nodes = set(nodes) - path_nodes
    dist_mat = dict() # dist_mat saves every nodes' distance to destination node
    for i in nodes:
        dist_mat[i] = [-1, float("inf")] # '-1' as undefined previous node, 'inf' as distance be infinite 
    dist_mat[start_node][0] = 'self' # the start node it self should be ['self', 0]
    dist_mat[start_node][1] = 0 * node_weight[start_node] # distance should multiplied by weight
    while unknown_nodes: # If there still have unknown nodes
        for fn in path_nodes: # for every node in the best path
            for en in node_lk[fn].keys(): # search all their children nodes
                if (dist_mat[fn][1] + node_lk[fn][en] * node_weight[en]) < dist_mat[en][1]:
                    dist_mat[en][1] = dist_mat[fn][1] + node_lk[fn][en] * node_weight[en] # Update from-src-distance for updated end_node with weight multiplied
                    dist_mat[en][0] = fn # Update previous-node for updated end_node
        temp_min_value = float('inf')
        for i in sorted(unknown_nodes):
            if dist_mat[i][1] < temp_min_value:
                current_min_node = i # any comparation find smaller distance, update the node name i
                temp_min_value = dist_mat[i][1] # and update the minimum distance
        unknown_nodes.remove(current_min_node) # find out the minimum distance node, remove it from the nodes that not in best path
        path_nodes.add(current_min_node)
        #print("shortest nodes already found for nodes: {}".format(path_nodes))
        #print(dist_mat)
    i = goal_node
    path = [] # path saves the best path from start node to destination node
    while i != start_node:
        # from the destination node search every parent node till start node
        path.append(i)
        i = dist_mat[i][0]
    path.append(start_node)
    path.reverse() # Because it search from destination node, reverse to get the start node to destination node path
    print("----------------------------------------------")
    print("The shortest path with weighted nodes is:")
    print(path) # print the path

if __name__=="__main__":
    parser = argparse.ArgumentParser(description='A routing tool implements with-direction BellmanFord, Dijkstra, Astar algorithm.') # initialize the commnad line arguments with help information
    parser.add_argument('--with_direction', dest = 'direction', action = 'store_true', default = 0, help = 'Whether the input is directed edges or undirected edges.') # the --with_direction argument, if have this option, the data will be treated as: every line is directed edge, from one node to another node
    parser.add_argument('--with_weight', dest = 'weight', action = 'store_true', default = 0, help = 'Whether the input file saves the weights of the nodes. If no, all nodes\' will be set to 1.') # the --with_weight option, with this option the program will read the 4th and 5th element in dataset line
    parser.add_argument('--start_node', dest = 'sn', action = 'store', help = 'The start node name.') # the --start_node, for dijkstra and astar algorithm, means the start node
    parser.add_argument('--destination_node', dest = 'en', action = 'store', help = 'The destination node name.')# --end_node, for bellmanford and astar algorithm, means the destination node
    parser.add_argument('--data_path', action = 'store', required = True, help = 'The input graph dataset path, with format [node_a],[node_b],[distance],[weight_a],[weight_b]') # where to read the dataset
    parser.add_argument('algorithm', choices = ['bellmanford','dijkstra','astar'], metavar = 'algorithm', action = 'store', help = 'Can be [bellmanford] or [dijkstra] or [astar]') # choose one algorithm, only three choices as described

    args = parser.parse_args()
    node_link, raw_graph, node_weight = ReadData(args.data_path, with_direction = args.direction, with_weight = args.weight) # read the data
    if args.algorithm == 'bellmanford':
        # if choose bellmanford, use this
        print("------\nSelected bellmanford algorithm. This algorithm receives directed, no weight graph and calculates the minimum distance from each node to destination node.")
        print("You selected destination node: {}".format(args.en))
        BellmanFord(args.en, node_link)
    if args.algorithm == 'dijkstra':
        # if choose dijkstra, use this
        print("------\nSelected dijkstra algorithm. This algorithm receives directed, no weight graph and calculates the minimum distance from start node to every other notde.")
        print("You selected start node: {}".format(args.sn))
        Dijkstra(args.sn, node_link)
    if args.algorithm == 'astar':
        # if choose astar, use this
        print("------\nSelected astar algorithm. This algorithm receives directed, weighted graph and calculates the minimum distance from start node to destination node.")
        print("You selected start node: {} and destination node: {}".format(args.sn, args.en))
        AstarSearch(args.sn, args.en, node_link, node_weight)
